
// Set this to true for production
var doCache = true;

console.log("sw fired, caches: ", caches);

var shellCacheName = 'pwa-weather-shell-v1';

// 'use strict';
// importScripts('./build/sw-toolbox.js');

// self.addEventListener('activate', function(e) {
//   console.log('[ServiceWorker] Activate');
//   e.waitUntil(
//     // Get all cache containers
//     caches.keys().then(function(keyList) {
//       return Promise.all(keyList.map(function(key) {
//         // Check and remove invalid cache containers
//         if (key !== shellCacheName) {
//           console.log('[ServiceWorker] Removing old cache', key);
//           return caches.delete(key);
//         }
//       }));
//     })
//   );
//
//   // Enforce immediate scope control
//   return self.clients.claim();
// });

// The first time the user starts up the PWA, 'install' is triggered.
// self.addEventListener('install', function(event) {
//   console.log("install:", event)
//   if (doCache) {
//     event.waitUntil(
//       caches.open(shellCacheName)
//         .then(function(cache) {
//           // Get the assets manifest so we can see what our js file is named
//           // This is because webpack hashes it
//           fetch("asset-manifest.json")
//             .then(response => {
//               console.log("response",response, typeof response)
//               return response.json()
//             })
//             .then(assets => {
//               console.log('assets', assets)
//               // Open a cache and cache our files
//               // We want to cache the page and the main.js generated by webpack
//               // We could also cache any static assets like CSS or images
//               const urlsToCache = [
//                 "/",
//                 assets["main.js"]
//               ]
//               cache.addAll(urlsToCache)
//               console.log('cached');
//             }).catch(function(error) {
//               console.log("error caught here", error)
//             });
//         })
//     );
//   }
// });

var CACHE = 'notification-experiment';

// self.addEventListener('fetch', function(evt) {
//   console.log('The service worker is serving the asset.')
//    evt.respondWith(fromCache(evt.request));
//    evt.waitUntil(update(evt.request));
// });

// self.addEventListener('fetch', function(event) {
//   console.log('attempting to fetch', event, event.request.url);
//   console.log(event.clientId);
//   event.respondWith(
//     // first fetch the asset from network
//     fetch(event.request)
//     .then(function(res) {
//     // save it to the cache
//       console.log("save it here")
//       return res
//
//     })
//     .catch(function() {
//       // if you cant get it, get it from the cache
//       return caches.match(event.request);
//     })
//   );
// });


self.addEventListener('fetch', function(event) {
  console.log("new fetch... ",event.request.url)
  event.respondWith(
    caches.open('mysite-dynamic').then(function(cache) {
      // opens cache, checks it
      return cache.match(event.request).then(function (response) {
        // returns cached item OR gets from network
        if(!!response) {console.log("Already in cache: ", response)}
        return response || fetch(event.request).then(function(response) {
          // puts it in cachce, and then responeds with value
          console.log("Doesn't have this in cache: ", response)
          cache.put(event.request, response.clone());
          return response;
        });
      });
    })
    .catch(function(err){
      throw console.log("Error, Not in cache and no network", err)
    })
  );
});




// dynamically cache any other local assets
// self.toolbox.router.any('/*', self.toolbox.cacheFirst);

// for any other requests go to the network, cache,
// and then only use that cached resource if your user goes offline
// self.toolbox.router.default = self.toolbox.networkFirst;



//
// self.addEventListener('fetch', function(e) {
//   console.log('[ServiceWorker] Fetch', e.request.url);
//   e.respondWith(
//     caches.match(e.request).then(function(response) {
//       console.log("response: ",response)
//       return response || fetch(e.request);
//     })
//     .catch( function() {
//       console.log("error of some kind")
//     })
//   );
// });

// self.addEventListener('fetch', function(event) {
//   console.log("fetch event: ", event)
//   event.respondWith(
//     fetch(event.request).then(function() {
//       console.log("Fetching something")
//     })
//     .catch(function() {
//       console.log("fetch event caught because there's no internet: ", event.request)
//       return caches.match(event.request);
//     })
//   );
// });

// function fromCache(request) {
//   return caches.open(CACHE).then(function (cache) {
//     return cache.match(request).then(function (matching) {
//       return matching || Promise.reject('no-match');
//     });
//   });
// }
//
// function update(request) {
//   return caches.open(CACHE).then(function (cache) {
//     return fetch(request).then(function (response) {
//       return cache.put(request, response);
//     });
//   });
// }
